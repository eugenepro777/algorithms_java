# Уроки 2, 3

## **Структуры данных. Массивы. Алгоритмы массивов**

### **Реализовать алгоритм пирамидальной сортировки (сортировка кучей)**

**В этом варианте используется метод buildHeap(), который строит max-кучу перед непосредственной сортировкой, применяя метод heapify(). Затем, во внешнем цикле, элементы извлекаются из max-кучи и помещаются в отсортированную часть массива. Этот вариант может быть немного более эффективным в практическом использовании, так как метод buildHeap() выполняется только один раз в начале, что может сэкономить некоторое время на больших массивах.**

**Пирамидальная сортировка (сортировка бинарной кучи) всегда имеет асимптотическую сложность – O(n log n), что делает её очень быстрой для сортировки массивов большого размера.**

**Это происходит потому, что пирамидальная сортировка обеспечивает эффективное упорядочение элементов массива, используя структуру данных max-кучи. Кроме того, эти алгоритмы не требуют дополнительной памяти, так как сортировка выполняется на месте, изменяя исходный массив.**

**Однако данный тип сортировки массивов используется реже чем быстрая сортировка из-за более сложной реализации.**

 ---

## **Структуры данных. Связный список**

### **Необходимо реализовать метод разворота связного списка (двухсвязного или односвязного на выбор).**

**Метод reverse() осуществляет разворот списка путем переворачивания ссылок между элементами. Мы инициализируем три переменные - previousNode, currentNode и nextNode. Изначально previousNode и nextNode равняются null, а currentNode указывает на головной элемент списка (head).**

**Затем мы проходимся по списку с помощью цикла, меняя ссылки узлов. На каждой итерации, сохраняем ссылку на следующий узел (nextNode), затем меняем ссылку текущего узла (currentNode) на предыдущий узел (previousNode). После этого переводим указатель предыдущего узла (previousNode) на текущий узел (currentNode), а указатель текущего узла (currentNode) переводим на следующий узел (nextNode).**

**По мере продвижения по списку, текущий узел идет с начала списка к концу, а previousNode с конца списка к началу. Когда цикл завершается и currentNode становится null, previousNode указывает на новую голову списка (бывшую хвостовую часть списка).**

**Наконец, мы присваиваем переменной head значение previousNode, чтобы обновить голову списка и завершить операцию разворота.**
